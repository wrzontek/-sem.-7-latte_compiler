/* File generated by the BNF Converter (bnfc 2.9.3). */

/************************* Compiler Front-End Test *************************/
/*                                                                         */
/*  This test will parse a file, print the abstract syntax tree, and then  */
/*  pretty-print the result.                                               */
/*                                                                         */
/***************************************************************************/

#include <cstdio>
#include <string>
#include <iostream>
#include "Parser.H"
#include "Printer.H"
#include "Absyn.H"
#include "ParserError.H"
#include "CFGVisitor.cpp"
#include "LivenessVisitor.cpp"
#include "CodeGenerator.cpp"
#include "OptimizationVisitor.cpp"
#include <filesystem>

void usage() {
    printf("usage: Call with one of the following argument combinations:\n");
    printf("\t--help\t\tDisplay this help message.\n");
    printf("\t(no arguments)\tParse stdin verbosely.\n");
    printf("\t(files)\t\tParse content of files verbosely.\n");
    printf("\t-s (files)\tSilent mode. Parse content of files silently.\n");
}

int main(int argc, char **argv) {
    FILE *input;
    int quiet = 0;
    char *filename = NULL;

    if (argc > 1) {
        if (strcmp(argv[1], "-s") == 0) {
            quiet = 1;
            if (argc > 2) {
                filename = argv[2];
            } else {
                input = stdin;
            }
        } else {
            filename = argv[1];
        }
    }

    if (filename) {
        input = fopen(filename, "r");
        if (!input) {
            usage();
            exit(1);
        }
    } else input = stdin;
    /* The default entry point is used. For other options see Parser.H */
    Program *parse_tree = NULL;
    try {
        parse_tree = pProgram(input);
    } catch (parse_error &e) {
        std::cerr << "Parse error on line " << e.getLine() << "\n";
    }
    if (parse_tree) {
        if (!quiet) {
            printf("\n[Abstract Syntax]\n");
            ShowAbsyn *s = new ShowAbsyn();
            printf("%s\n\n", s->show(parse_tree));
            printf("[Linearized Tree]\n");
            PrintAbsyn *p = new PrintAbsyn();
            printf("%s\n\n", p->print(parse_tree));
        }
        // TODO jak będą optymalizajce to walnąć flagę (z latc) żeby wyłączyć

        auto path = std::filesystem::path(filename);
        auto cfg_visitor = new CFG_Visitor(parse_tree);
        parse_tree->accept(cfg_visitor);
        cfg_visitor->setPred();
//        cfg_visitor->printSucc();
//        cfg_visitor->printPred();

        auto liveness_visitor = new Liveness_Visitor(parse_tree, cfg_visitor->succ, cfg_visitor->pred,
                                                     cfg_visitor->block_code);
        liveness_visitor->analyze_liveness();

        auto optimization_visitor = new Optimization_Visitor(parse_tree, liveness_visitor);
        optimization_visitor->eliminate_dead_code();

        auto function_local_vars_visitor = new Function_Local_Vars_Visitor(liveness_visitor->block_out_vars);
        parse_tree->accept(function_local_vars_visitor);

        auto code_generator = new Code_Generator(parse_tree, path.replace_extension("s"),
                                                 liveness_visitor->block_out_vars, liveness_visitor->block_in_vars,
                                                 function_local_vars_visitor->function_local_vars,
                                                 function_local_vars_visitor->functions_with_string_result);
        code_generator->generate();
        code_generator->close();

        delete (parse_tree);
        return 0;
    }
    return 1;
}

